자료구조 (Data Structure), 알고리즘(Algorithm)
자료구조 (메모리), 알고리즘(속도)

어떻게 하면 최저의 비용으로 최고의 성과를 낼지 ?
메모리가 줄어들면, 속도도 줄어든다. (비용감소)
메모리가 증가하면, 속도도 빨라진다. (비용증가)

- 자료구조 : 데이터를 효율적으로 저장, 조직화, 관리하기 위한 방법이다. (알고리즘에 가장 큰 영향을 미침)
    1. 배열(Array) : 동일한 유형의 요소들의 데이터들이 연속적인 메모리 공간 저장되는 자료구조.
        1) 연속적인 메모리 공간 : 배열의 데이터들이 메모리에서 연속적으로 할당되기 때문에, 인덱스로 통해 데이터에 접근할 수 있다.
        2) 고정된 크기 : 배열은 생성할 때, 크기가 결정되며 일단 생성된 배열의 크기는 변경할 수 없다.
        3) 인덱스 기반 접근 : 시작 요소가 0번째로 시작된다. 
           인덱스 기반 접근이기 때문에 빠른 읽기와 쓰기 작업이 가능하다. 
        4) 동일한 유형의 데이터 저장

        장점 : 속도가 빠르다. 연속적인 할당으로 캐시 지역성(Cache Locality) 성능 향상
        단점 : 크기 제약, 삭제와 삽입이 불가능, 메모리 낭비


    2. 스택(Stack)과 큐(Queue) 
        • 스택(Stack) : 후입선출(LIFO, Last-In-First-Out) - 마지막에 삽입된 요소가 가장 먼저 제거된다. 
            push, pop, peek/top
                - push : 스택의 맨 위의 요소를 추가한다.
                - pop : 스택의 맨 위의 요소를 제거하고 반환한다.
                - peek/top : 스택의 맨 위의 요소를 조회한다.
            
            함수 호출과 복귀 :  함수 호출 시 호출된 함수의 정보(지역변수, 매개변수 등)을 스택에 저장하고, 함수가 완료되면 역순으로 복귀한다.
            괄호 검사 : 괄호 짝이 맞는지 확인하기 위해 여는 괄호가 나오면 Stack에 push를 하고 (닫는 괄호가 나올 때까지), 짝을 이루면 pop을 한다.
            뒤집기 : 문자열, 배열 스택에 넣고 순서대로 꺼내면 역순이 된다.

        • 큐(Queue) : 선입선출(FIFO, First-In-First-Out) - 가장 처음 삽인된 요소가 가장 먼저 제거된다.
            Enqueue : 큐의 뒤쪽(reer)의 요소를 추가한다.
            Dequeue : 큐의 앞쪽(front)의 요소를 제거하고 반환한다.
            Front, Peek : 큐의 앞쪽에서 요소를 조회한다.

            작업 대기열 (Task Queue) : 여러 작업들이 한꺼번에 들어올 때 순서대로 처리하기 위해 큐를 사용한다.
            너비 우선 탐색 (BFS, Breadth-First-Search) : 그래프나 트리 탐색 시 BFS에서 인접한 정점들을 방문 순서대로 처리한다. 


    3. 연결리스트 (Linked List) : 노드(Node)둘이 포인터로 서로 연결되어 있는 자료구조
        • 노드 : 데이터와 다음 노드를 가르키는 포인터 (주소)

        1) 단일 연결 리스트 (Single Linked List)
            각 노드는 데이터 필드와 다음 노드를 가르키는 포인터 필드로 구성된다. 마지막 노드의 포인터 필드 값이 보통 NULL 이며,
            이는 리스트의 끝을 나타낸다.

            장점 : 삽입, 삭제가 효율적이고 간단하다. 앞, 뒤 노드만 수정하면 되기 때문에 동적 크기 조정이 가능하다.
            단점 : 특정 위치에 직접 접근하기 위해서는 처음부터 순차적으로 탐색해야 한다. (탐색시간이 증가할 수 있다.) 

            ※ SingleLinkedList.js & SingleLinkedList.py 파일 예시 참고

        
        2) 이중 연결 리스트 (Doubly Linked List)
            각 노드는 데이터 필드와 이전 노드를 가리키는 포인터 필드, 다음 노드를 가르키는 포인터 필드로 구성된다.
            첫 번째 요소와 마지막 요소에 대한 접근이 가능하다.

            장점 : 양방향으로 탐색이 가능하여 특정 위치에서의 삽입과 삭제가 단일 연결리스트보다 효율적이며 역방향 탐색 및 반대방향에서의
                   삽입/삭제가 가능하다.
            단점 : 이전(Prev) 포인터를 유지해야하므로 추가 메모리 공간을 사용한다. 

                1. 삽입 (insetion)
                2. 삭제 (Deletion)
                
            이중 연결 리스트
            class Node {
                int data;
                Node prev;
                Node next;
            }


    4. 트리 (Tree) :
    5. 해시 테이블 (Hash Table) :