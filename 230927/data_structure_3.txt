- 알고리즘

재귀(Recursion), 탐색(Searching), 정렬(Sorting)

- 탐색 알고리즘 : 데이터 구조에서 특정 값을 찾는 방법

    1. 선형 탐색 (Linear Search) : 가장 간단한 형태의 알고리즘. 
        ▸ 동작방식 ⇾ 리스트의 처음부터 끝까지 원하는 요소를 찾을 때까지 하나하나 확인한다. 
        시간 복잡도가 최선의 경우 O(1), 최악의 경우 O(n) 이다. 여기서 n은 리스트의 길이를 나타낸다. 
        정렬에 대한 의미가 없다. (데이터가 정렬되어 있지 않아도 사용 가능)

    2. 이진 탐색 (Binary Search) : 이진 탐색은 정렬된 배열에서 특정 값을 찾는데 사용되는 효율적인 알고리즘. 
        ▸ 동작방식 ⇾ 배열의 중간 요소를 선택. 찾고자 하는 값과 중간 값과의 비교를 수행
        데이터의 중간 요소를 확인하고 찾고자 하는 값이 중간 값보다 작으면 왼쪽 반쪽을, 크면 오른쪽 반쪽을 선택하여 계속 반씩 탐색해 나간다. 
        매 단계 검사해야 할 요소가 절반으로 줄어 시간 복잡도는 O(log N)이다. 
        ※ 예시 : BinarySearch.py 파일 코드 참고


    - 알고리즘 복잡도 : 알고리즘이 얼마나 많은 리소스를 사용하는지 측정하는 방법
        • 시간 복잡도 : 알고리즘이 문제를 해결하는데 얼마나 많은 시간이 필요한지를 측정.
                    입력 크기에 따른 연상 횟수로 표현하며 이 연산 횟수가 증가하는 속도를 나타내는 것이 중요하다. 
        • 공간 복잡도 : 알고리즘이 문제를 해결하는데 얼마나 많은 메모리가 필요한지는 측정.
                    입력 데이터 외에 추가적으로 필요한 공간.

        Big O notation은 시간 및 공간 복잡도를 표현하기 위한 수학 표기법
        O()은 최악의 경우*(worst case scenario)에서 알고리즘의 성능을 의미하며 입력 크기 n에 대한 함수의 상한선(upper bound)를 제공한다. 

        1. O(1) ⇾ 상수 시간(constant time) : 입력 크기와 무관하게 항상 동일한 시간이 걸린다. 
        2. O(n) ⇾ 선형 시간(linear time) : 입력 크기에 비례해서 처리 시간이 증가한다. 
        3. O(n^2) ⇾ 제곱 시간(quadratic time) : 입력 크기의 제곱에 비례해서 처리 시간이 증가한다. 
        4. O(log n) ⇾ 로그 시간(logarithmic time) : 로그 함수와 같이 초기에 빠르게 감소하다가 점차 감소 속도가 줄어든다. 
        5. O(n lig n) ⇾ 선형 로그 시간(linear logarithmic time) : 선형시간과 로그시간의 곱만큼 처리시간이 증가한다. 

        1 - 4 - 2 - 4 - 3 - 5

- 정렬
    lst = [11, 3, 24, 9, 40, 33, 7, 2, 8, 30]

    1. 선택정렬(Selection Sort) : 가장 간단하지만 효율성이 떨어지는 정렬 알고리즘 중 하나다. 
        기본 아이디어는 매 순환(linear Search)에서 가장 작은(큰) 요소를 찾아 위치를 이동하여 정렬하는 것. 
        순서 : 
            1) 리스트에서 최소값을 찾는다.
            2) 그 값을 첫 번째 값과 교환한다. 
            3) 남은 리스르 중 가장 작은 값을 두 번째 값과 교환한다. 
            4) 이 과정을 전체 리스트가 정렬될 때 까지 반복한다. 

        시간복잡도 : O(n^2) ⇾ 반복문 길이 n짜리 이중 반복문

        .ex 코드 : SelectionSort.py 참고

    2. 삽입정렬(Insertion Sort) : 
        1) 리스트의 두 번쨰 요소부터 시작하여 현재 키를 그 이전의 모든 요소와 비교한다. 
        2) 키가 이전 요소보다 작으면, 이전 요소를 한 위치 오른쪽으로 이동시킨다. 
        3) 키가 이전 요소보다 큰 위치를 찾을 때 까지 혹은 모든 이전 요소를 확인할 때까지 반복한다. 
        4) 원하는 위치에 키 값을 삽입한다. 
        5) 해당 과정을 모든 요소에 대해 반복하여 정렬한다.

        .ex 코드 : InsertionSort.py 참고



